## js执行机制

### 全局执行上下文

执行全局代码的时候由JavaScript创建，并且只有一份

### 执行上下文

1. 创建时机

   - 函数执行时，函数体内的代码被编译，创建执行上下文

     函数执行结束后被销毁

   - 执行eval函数，eval的代码会被编译，创建执行上下文

### 调用栈

用来管理**函数调用关系**的数据结构，用于追踪函数调用

函数执行前会被编译，编译时函数的执行上下文入栈

### 栈溢出

1. 避免方法
   - 注意递归的使用
   - 用定时器来拆分任务

### 块级作用域变量原理

#### 变量环境&词法环境

变量环境存放函数和var声明

词法环境以栈的形式存放let、const形成的块，当块被编译时入栈，当块内部的所有代码都执行完成后整个块出栈

1. 函数被编译时
   - var存放在**变量环境**
   - let、const变量作为一个块被压入在**词法环境**
2. **函数内部的块**被编译时
   - let、const变量作为一个新的块被压入在**词法环境**

#### 变量查找规则

（遵循词法作用域）先从词法环境的栈顶往栈底查找变量，有则使用，无则转到变量环境中查找

### 作用域链

由词法作用域决定

#### 词法作用域

由**函数声明的位置**决定的作用域，为静态作用域

#### 外部执行上下文

函数的词法作用域的地方

bar与foo的（词法作用域）外部执行上下文都是全局执行上下文

```js
function bar() {
  console.log(myName);
}
function foo() {
  var myName = '蜗牛'
  bar()
}
var myName = '周老板'
foo()
```

而add的外部执行上下文是addAll

```js
function addAll(b, c) {
  var d = 10
  var a = 3
  result = add(b, c)
  return a + result + d
  // function add() {
  //   console.log(a); // 作用域链的关系会打印3
  //   return b + c
  // }
  // add()
}
addAll(3, 6)
```

#### 外部引用

1. 每个执行上下文的变量环境中都包含一个指向外部执行上下文的外部引用（outer）
2. 变量查找规则：在当前作用域找不到时就去外部引用指向的外部执行上下文中查找

### 闭包

根据词法作用域的规则，内部函数总是可以访问外部函数声明的变量。

当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经结束，但是内部函数引用外部函数的变量依然可以保存在内存中，我们称这些变量为闭包的产物，这些变量的集合就称之为闭包

#### 回收机制

1. 被**全局**变量引用的闭包，那么该闭包就会一直存在直到页面关闭
2. 被**局部**变量引用的闭包，等该变量被销毁后，在下一次JavaScript引擎执行垃圾回收时，判断闭包不再使用了才被垃圾回收
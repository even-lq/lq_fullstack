## UDP

传输层协议： UDP ，TCP

### UDP协议（用户数据包协议）

##### 特点

1. 无连接。面向无连接的传输协议（不需要在正式传递数据之前就连接双方），UDP 为[应用程序](https://baike.baidu.com/item/应用程序/5985445)提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。（不需要三次握手）
2. 不可靠。UDP只提供[数据](https://zh.wikipedia.org/wiki/数据)的不可靠传递，不保证各个数据报的先后顺序，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份，不保证是否丢失
   - 不解析数据。
   - 没有拥塞控制。不会依据网络状况调节传输的数据，即网络畅通时传输的数据量大，反之少，不同于TCP的流量控制（即时通讯）

##### 优点

1. 简单高效。不需要保证数据不会丢失且有序（报文首部开销小，只有8字节，TCP20字节）

##### 传输方式

支持多播和广播



发送端:应用层(浏览器) -->传输层(UDP) -->网络层
接收端:网络层-->传输层-->应用层

##### 应用场景

即时通讯、[流媒体](https://zh.wikipedia.org/wiki/串流媒體)、[在线游戏](https://zh.wikipedia.org/wiki/線上遊戲)

### TCP协议

要建立连接，传输过程有各种算法保证数据的可靠性，没有UDP高效

#### 三次握手

https://juejin.cn/post/6844903958624878606

##### 简单版本

![三次握手-easy](D:\Desktop\百度搜索一面准备\网络\三次握手-easy.png)

- 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口`（第一次握手，由浏览器发起，告诉服务器我要发送请求了）`

- 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息`（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）`

- 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”`（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）`

  作者：williamife
  链接：https://juejin.cn/post/6844903784229896199
  来源：掘金
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### 完全版

![三次握手&数据传输&四次挥手](D:\Desktop\百度搜索一面准备\网络\三次握手&数据传输&四次挥手.jpg)

三次握手

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SENT` 状态。

  首部的**同步位SYN=1，初始序号seq=x，SYN=1**的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RCVD` 的状态。

  在确认报文段中**SYN=1，确认号ACK=x+1，初始序号seq=y**。

- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。

  **确认号ACK=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1）**，ACK报文段可以携带数据，不携带数据则不消耗序号。

数据传输

- 数据传输的过程是单向的（请求-响应），首先还是要发送ACK报文（回应服务端的序号 y+1），并且发送客户端的序号（x+1）
- 服务端响应发送客户端发送的序号，把客户端的序号+1作为ACK的值传过去（ACK + 2）

为什么要有SYN同步序列号，seq，ACK？

> [TCP 三次握手背的滚瓜乱熟，那意外情况呢？丢包了呢？故意不回复 ACK 呢？](https://www.cnblogs.com/shijingxiang/articles/12174425.html)

在因网络等原因导致丢包的情况时，可以触发错误重传的机制

四次挥手

四次挥手发生了仅有的两次中服务端主动向客户端发送自己的序号的最后一次

1. 客户端向服务端发送释放连接请求

   此时客户端发送的序号在之前的基础上+1（x+2），确认之前服务端的序号的ACK包（y+1）

   **FIN seq=x+2 ACK=y+1**

2. 服务端接收到释放请求，会告诉应用层要释放TCP连接了，就会发送
   ACK包，并进入CLOSE_ wait状态(客服端是不能向服务端发数据了，但
   是服务端还可以向客户端发送数据)

   此时服务端发送确认客户端发送的序号——**ACK（x+3）**

3. 如果有数据没传完，服务端继续把这最后一次传完到客户端

4. 客户端接收到最后一次数据后向服务端发起确认断开请求

   此时服务端主动向客户端发送自己的序号**seq=y+1**(这是第二次，第一次在握手的第二次)

5. 客户端只可以传输**确认ACK=y+2**，过了一定的时间后如果没有得到应达，就自动断开



![三握四挥简单版](D:\Desktop\百度搜索一面准备\网络\三握四挥简单版.png)

#### 为什么TCP建立连接需要三次握手？明明两次就已经建立连接了

因为要维护双方数据原点的序列号**（Initial Sequence Number）**



为了实现可靠数据传输，TCP 协议的通信双方，都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 

三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤

如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认



[TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633) 禁止转载



**第一个包，即A发给B的SYN中途被丢,没有到达B**

A会周期性超时重传，直到收到B的确认

**第二个包，即B发给A的SYN + ACK中途被丢,没有到达A**

B会周期性超时重传，直到收到A的确认

**第三个包，即A发给B的ACK中途被丢,没有到达B**

A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态:

a.假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP连接
也为Established状态，双向可以发包。

b.假定此时A有数据发送，B收到A的Data + ACK,自然会切换为established 状态，并接受A的Data.

c.假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK,直到收到A的确认才可以发送数据。

#### 四次挥手

1. 客户端向服务端发送连接释放请求
2. 服务端接收到释放请求，会告诉应用层要释放TCP连接了，就会发送
   ACK包，并进入CLOSE_ wait状态(客服端是不能向服务端发数据了，但
   是服务端还可以向客户端发送数据)
3. 如果有数据没传完，服务端继续把这最后一次传完到客户端
4. 客户端接收到最后一次数据后向服务端发起确认断开请求，2ms后如
   果没有得到应达，就自动断开

协议也是函数
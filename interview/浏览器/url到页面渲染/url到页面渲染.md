### url到页面渲染（上）

#### 定位

IP协议 => DNS域名解析 => TCP协议（三次握手，四次挥手）

### url到页面渲染（下）

浏览器接收到html文件后先做**词法分析**，把内容拆分开来，打成标记，转换为结点，再拼接成一颗dom树

浏览器接收到css文件也是一样的生成cssom树，cssom树中包含递归的操作（递归渲染

dom树 + cssom树 结合成 渲染树（只包含需要显示的节点（不存在display:none的结点））

浏览器拿渲染树去绘制页面（GPU）（回流）

#### 浏览器接收到html文件

1. 词法分析

   浏览器从字节转为字符串后先转为许多个标记

   - 标记  =>  node结点(html标签) => dom树

#### 浏览器接收到css文件

1. 词法分析
   - 操作同上，但是转为cssom树

#### 渲染树

dom树 + cssom树 = render树

渲染树只包含需要显示的节点（不存在display:none的结点）

#### 回流

根据render树绘制页面布局(GPU绘制)

#### 重绘和回流

重绘：结点需要改变外观而不影响布局

回流：结点的几何信息发生变化

回流一定会造成重绘，反之则不一定

引起回流的操作：

1. 改变window大小
2. 改变字体大小
3. display: none(改用opacity，visible)
4. 获取结点几何信息的方法offsetTop等
   1. 改变table布局里面的元素

#### 什么情况下会阻塞渲染

html，css

` <script></script>`

#### html书写方式的性能优化

1. css用单独的类名，减少类，标签的嵌套，保持扁平化 

   减少递归渲染，同理html不要嵌套没有意义的标签

   ```css
   span {
       color: red;
   }
   /* 浏览器会先找所有span，然后再找装在a标签里面的span，还要找被a标签包裹而且被div包裹的span，需要递归寻找*/
   div > a > span {
       color: red;
   }
   ```

#### 为什么操作DOM性能很差?

1. 操作dom会导致多线程并发

   浏览器存在渲染引擎和js引擎，当用js操作dom时(document.getElementById)，需要两个引擎之间通信，也就是多线程通信，多线程并发工作，造成性能开销大

2. 可能引起重绘和回流

#### 一次性插入几万个dom，怎么实现不卡顿

1. 节流

   每隔限定的毫秒去插入

2. 虚拟滚动
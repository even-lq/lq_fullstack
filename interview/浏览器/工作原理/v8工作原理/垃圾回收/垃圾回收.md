## 垃圾回收

手动回收：例如C、C++

自动回收：例如JAVA、JavaScript、python

### JavaScript

ESP：指向当前执行上下文的指针。如果当前ESP执行下一个执行上下文，那么当前执行上下文被销毁



#### 栈中的垃圾数据

JavaScript引擎会通过**向下移动ESP指针**来销毁函数保存在栈中的执行上下文

#### 堆中的垃圾数据

##### 代际假说

代际假说(人为的一种认知) : 

1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存， 很快就变得不可访问。

2. 不死的对象会活得更久

v8会把堆分成新生代和老生代两个区
新生代：存放生存时间短的对象   1~8M的容量   被副垃圾回收器回收
老生代：存放生存时间长的对象   很大                 被主垃圾回收器回收

###### 副垃圾回收器回收

1. 主要负责**新生区**的垃圾回收，通常情况下，**大多数小的对象**都会被分配到新生区，但是**回收是很频繁**的
2. scavenge算法会把新生区的内存一分为二，分成**对象区域**和**空闲区域**，然后标记对象区域里面所有的对象,
3. 把**活对象**复制到**空闲区域**，此过程还会做好**排序**，相当于是做了**内存整理**。
4. 然后**清空对象区域**，**反转两个区域**，把空对象区域置为空闲区域，而带有活对象的空闲区域置为对象区域

###### 主垃圾回收器回收

1. 当新生区的存活对象过多而导致空间不够时，js会采用**对象晋升策略**(经过两次垃圾回收还存活的对象，直接移动到老生区)

2. **本身很大的对象**存放在老生区

3. 标记+清除算法

   首先是标记阶段(递归遍历的区标记一组对象，但凡是能找到一个节点是活对象，那这组对象就是活对象，一个活对象节点都没有的成为垃圾数据)，然后清除

##### 回收流程

当函数执行完，ESP指向**下一个执行上下文**时，（老生区的标记流程）递归遍历查询整个调用栈，查询是否有还要使用的对象（活对象），没有就清除，有就保存

##### 分代收集

##### 垃圾回收器的工作流程

不论什么类型的垃圾回收器，都有一套共同的执行流程

1. 标记空间中的活动对象(还在使用的对象)和非活动对象(可以进行垃圾回收的对象)

2. 回收非活动对象所占据的内存

3. 做内存整理，频繁回收对象后，就会出现大量不连续的空间(内存碎片)

#### 全停顿

因为javaScript是运行在v8的主线程上的，而垃圾回收的算法也在主线程，那么就会出现当需要垃圾回收时,js的运行会暂停，等到垃圾回收完毕后再恢复运行——全停顿

1. 全停顿在新生区没有太大的影响（因为内存小）

2. 对于老生区采取增量标记算法

   V8将标记过程分成一个个**子标记**的过程，同时让垃圾回收标记和js应用逻辑**交替进行**，直到标记完成
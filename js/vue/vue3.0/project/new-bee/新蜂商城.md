# 新蜂商城

## 安装依赖

```bash
npm i lib-flexible
npm i vant@next -S
npm i axios
npm i vue-img-verify
npm i js-md5
```

## CSS

### 属性解析

```css
1. 字体抗锯齿渲染:
-webkit-font-smoothing: antialiased; // 抗锯齿很好 
-moz-osx-font-smoothing: grayscale; // 抗锯齿很好 

2. 控制元素在移动设备上是否使用滚动回弹效果.
-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */

3. CSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。
will-change: transform;

4. 当元素背面朝向观察者时是否可见
元素的背面是其正面的镜像。虽然在 2D 中不可见，但是当变换导致元素在 3D 空间中旋转时，背面可以变得可见。 （此属性对 2D 变换没有影响，它没有透视。）
backface-visibility: hidden;
注：硬件加速度
```

## vue3

### 语法

1.  this.$refs 和 获取组件的value

   ```js
   <template>
     <div class="img-verify">
       <canvas ref="verify"></canvas>
     </div>
   </template>
   
   <script>
   export default {
     setup() {
       // this.$refs.verify
       const verify = ref(null);
   
       return {
         verify
       }
     }
   }
   </script>
   
   <template #button>
       <vue-img-verify ref="verifyRef"/>
   </template>
   const verifyRef = ref(null);
   const onSubmit = async() => {
       console.log(verifyRef.value.imgCode);
       // 取组件的value值其实就是取该组件setup函数返回的对象（proxy对象）
   }
   ```

2. router

     `const router = useRouter();`要放在setup函数的内，不要嵌套在别的函数里面否则无法识别。

3. props

   传入的props可以直接用，不用经过响应式函数的封装

   ```js
   <s-header :name="type == 'login' ? '登录' : '注册'"></s-header>
   
   <template>
     <header class="simple-header">
       <van-icon name="arrow-left" @click="goBack" />  
       <div class="simple-header-name">{{name}}</div>
       <van-icon name="weapp-nav" />  
    </header>
   </template>
   
   <script>
   import { reactive, ref, toRefs } from 'vue'
   import { useRoute } from 'vue-router';
   export default {
     props: {
       name: {
         type: String,
         default: ''
       }
     }
   }
   </script>
   ```

   

## 接口请求

### axios封装

```js
import axios from 'axios'
import router from '../router'
import { Toast } from "vant";

axios.defaults.baseURL = '//47.99.134.126:28019/api/v1';
axios.defaults.headers['X-Requested-With'] = 'XMLHttpRequest';
axios.defaults.headers["token"] = localStorage.getItem("token") || "";
axios.defaults.headers.post['Content-Type'] = 'application/json';

axios.interceptors.response.use(res => {
  if (typeof res.data !== 'object') {
    Toast.fail('服务端异常！')
    return Promise.reject(res);
  }
  if (res.data.resultCode !== 200) {
    res.data.message && Toast.fail(res.data.message);
    res.data.resultCode === 416 && router.push({ path: "/login" });
    return Promise.reject(res.data);
  }
  return res.data;
})

export default axios;
```

## 业务

### 图片防盗用

main.js

```js
const app = createApp(App)

// 全局过滤器
app.config.globalProperties.$filters = {
  prefix(url) {
    if (url && url.startsWith('http')) {
      return url;
    }
    else {
      url = `http://47.99.134.126:28019${url}`
      return url;
    }
  }
}

<img :src="$filters.prefix(item.goodsCoverImg)" alt="">
```

### 验证码

获取dom的值

```js

```



## 性能优化

1. css

   - 属性

     ```css
     will-change: transform;
     ```

   - 硬件加速

     我们可以在浏览器中用css开启硬件加速，使GPU (Graphics Processing Unit) 发挥功能，从而提升性能。

     CSS animations, transforms 以及 transitions 不会自动开启GPU加速，而是由浏览器的缓慢的软件渲染引擎来执行。那我们怎样才可以切换到GPU模式呢，很多浏览器**提供了某些触发的CSS规则**。

     现在，像Chrome, FireFox, Safari, IE9+和最新版本的Opera都支持硬件加速，**当它们检测到页面中某个DOM元素应用了某些CSS规则时就会开启，最显著的特征的元素的3D变换。**

     如果要对一个元素进行硬件加速，可以应用以下任何一个 property (并不是需要全部，任意一个就可以)：

     ```css
     perspective: 1000px;
     backface-visibility: hidden;
     transform: translateZ(0);
     ```

   - 监测

     我们可以通过工具，例如 [CSS Triggers](https://csstriggers.com/) 来查看哪些属性会在动画时触发重绘。

# 数据库

mysql中的UTF-8MB4才是真正的UTF-8

## 索引

> [MySQL索引创建及使用](https://blog.csdn.net/dengchenrong/article/details/88425762)

普通索引

```js
create index idx_name on tableName(columnName) // 创建app索引在tableName的name字段上
```

唯一索引

```js
create unique index uniq_name on tableName(columnName) 
```

主键索引

```js
create primary index app on tableName name 
```

联合索引

```js
create unique index app on tableName(col1, col2)
```

删除索引

```js
drop index idx_name on tablename
```

创建主键

```js
alter table tablename add primary key(col)
```

### 常见索引结构

1. 二叉搜索树

   - 要求是每个节点的左子节点小于父节点，右子节点大于父节点
   - **查询效率**高
   - 时间复杂度O(logN)

2. 有序序列（数组）

   占用空间少，可以通过二分查找加速索引查询

   - 可以**区间查询**

   - 修改删除操作**性能低**，需要移动数据
   - 一般用于静态数据存储，对静态数据做索引

3. 哈希表

   键值对的方式存储，查询速度快（key-value，内存直接读取）

   - 只适用于**等值查询**，
   - 无法区间查询，比如redis（key-value数据库）

### mysql索引类型

为什么要用树结构？

因为要尽量减少磁盘I/O的读取次数

##### myisam（B树）

![img](https://user-gold-cdn.xitu.io/2019/6/26/16b939c623d3ad0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

特点：

1. 不再是二叉搜索，而是**m叉搜索**；

2. **叶子节点，非叶子节点**，都存储数据；

3. 中序遍历，可以获得所有节点；

##### innodb（B+树）

![img](https://user-gold-cdn.xitu.io/2019/6/26/16b939c6240791ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. **非叶子节点**不再存储数据

   `数据只存储在同一层的叶子节点上`；

   B+树中根到每一个节点的路径长度一样，而B树不是这样。

2. 叶子之间增加了**链表**，获取所有节点，不再需要中序遍历；

   这些改进让B+树比B树有更优的特性：

   - 范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；

     范围查询（区间查询）在SQL中用得很多，这是B+树比B树最大的优势。

   - 叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储；
   - 非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引；

> 作者：58沈剑_架构师之路
> 链接：https://juejin.cn/post/6844903875279847431
> 来源：掘金
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### B树与B+树的区别

1. B+ 树 **只有叶节**点会存放数据，B树的**每个节点**都会存放数据
2. B+ 树 的**叶子节点**都会通过**链表**有序链接，能够很快地实现区间查询
3. B树可以在非叶子节点结束查找，最好的情况是**O(1)**,B+树的时间复杂度是**O(logN)**
4. B树的**插入性能**比B+树要高

回表

- 回表就是先通过数据库**索引**扫描出数据所在的行，再通过行**主键id**取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树;

- 因此，可以通过索引先查询出id字段，再通过主键id字段，查询行中的字段数据，即通过再次查询提供MySQL查询速度。

## 范式

> ​	[搞懂关系型数据库的三大范式，又是一个能与面试官扯上一会的知识！](https://juejin.cn/post/6844904190427430920)

第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以此类推。一般说来，数据库只需满足第三范式(3NF）就行了。所以这里就只记录三范式相关的知识。

1. 1NF:字段不可分，每个字段是原子级别的，上节中看到第一个字段为ID，它就是ID不能在分成两个字段了，不能说我要把这个人的ID、名称、班级号都塞在一个字段里面，这个是不合适的，对以后的应用造成很大影响；
2. 2NF:有主键，非主键字段依赖主键，ID字段就是主键，它能表示这一条数据是唯一的，有的读者朋友记性很好，“unique”表示唯一的、不允许重复的，确实它经常会修饰某个字段，保证该字段唯一性，然后再设置该字段为主键；
3. 3NF:非主键字段不能相互依赖，这个怎么理解呢，比如student表，班级编号受人员编号的影响，如果在这个表中再插入班级的班主任、数学老师等信息，你们觉得这样合适吗？肯定不合适，因为学生有多个，这样就会造成班级有多个，那么每个班级的班主任、数学老师都会出现多条数据，而我们理想中的效果应该是一条班级信息对应一个班主任和数学老师，这样更易于我们理解，这样就形成class表，那么student表和class表中间靠哪个字段来关联呢，肯定是通过“classNo”，这个字段也叫做两个表的外键，
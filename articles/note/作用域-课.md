# js执行引擎
  分为编译和执行两个步骤，编译交由编译器编译代码
# 编译器
# 作用域
- 查找变量的顺序
  从里往外找
- 词法作用域层级
  两大层级：函数{}，windows全局
  函数的{}是一个作用域，可以访问全局变量，而反过来在windows全局作用域中不可以访问function作用域里面的变量
  - 特例
    1. eval() 欺骗词法作用域
        将eval()里面的参数搬进eval()同级的词法作用域里面并生效
        
    2. with：重复引用同一个对象中的多个属性的快捷方式
        
      with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对
      象的属性也会被处理为定义在这个作用域中的词法标识符。
      
      修改对象的属性，若修改的对象不存在该属性，则给该对象添加属性，并将该属性完全隔离成一个词法作用域。
        该全新的词法作用域将会泄露到windows（全局）
- 块级作用域
  不完全对：函数会给自己创建一个作用域，而其他结构不会
  如：for (var i = 0; i < 10; i++) 里面的i，在全局作用域可以打印（var i = 0的本质就是在全局作用域中创建的）
  var 使得if、for等内的变量在全局内创建，扰乱变量的作用域范围
  let 可以给if、for等创建块级作用域{},制约{}内变量的作用范围
  ```js
  var foo = true
  if (foo) {
    var a = 2
  }
  console.log(a) // 2
  // 如果改成let就无法访问，达到块级作用域的效果
  ```
  
  - let
  - with：从对象中创建出作用域（仅在 with 声明中而非外
    部作用域中有效）
  - try/catch
- 变量重名和最小暴露原则：隐藏函数和变量
  - 具名函数：可以在函数和变量外面套一层函数，实现函数和变量在全局作用域的隐藏
  
  - 匿名函数：让函数和变量外面包裹一层自执行函数，实现函数和变量在全局作用域的隐藏
  
  - 结合两者的有点：行内函数表达式
  
    函数表达式不是函数声明，因此不会污染作用域，但是匿名的函数表达式会带来调试困难，引用自身困难和可读性差的问题，而行内函数表达式可以解决这个问题
  
    ```js
    // setTimeout 的参数是函数，他可以是匿名的，可以给他起名字成为行内函数表达式
    setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
    console.log( "I waited 1 second!" );
    }, 1000 );
    ```
  
  - 自执行函数
  
    > ```js
    > var a = 2;
    > (function foo() {
    > var a = 3;
    > console.log( a ); // 3
    > })();
    > console.log( a ); // 2
    > ```
    >
    > 由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个
    > ( ) 可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个 ( ) 将函数变成表
    > 达式，第二个 ( ) 执行了这个函数。
    >
    >  (function(){ .. }())  自执行函数的另一种调用方式
  
    - 进阶用法：把它们当作函数调用并传递参数进去
  
      ```js
      var a = 2;
      (function IIFE( global ) {
      var a = 3;
      console.log( a ); // 3
      console.log( global.a ); // 2
      })( window );
      console.log( a ); // 2
      ```
  
      将 window 对象的引用传递进去，但将参数命名为 global 
  
    - 倒置代码的运行顺序
  
      ```js
      (function IIFE( def ) {
      def( window );
      })(function def( global ) {
      var a = 3;
      console.log( a ); // 3
      console.log( global.a ); // 2
      });
      ```
  
      函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def ）被传递进
      IIFE 函数定义的第一部分中。最后，参数 def （也就是传递进去的函数）被调用，并将
      window 传入当作 global 参数的值。

- 规避变量冲突的方法

  - 全局命名空间

    在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。

  - 闭包

  - let

  - 模块管理